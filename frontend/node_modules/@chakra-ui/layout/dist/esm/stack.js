function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { chakra, forwardRef } from "@chakra-ui/system";
import { cx, getValidChildren, mapResponsive, __DEV__ } from "@chakra-ui/utils";
import * as React from "react";
export var StackDivider = props => {
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    className: "chakra-stack__divider"
  }, props, {
    __css: _extends({}, props.__css, {
      borderWidth: 0,
      alignSelf: "stretch",
      borderColor: "inherit",
      width: "auto",
      height: "auto"
    })
  }));
};
export var StackItem = props => /*#__PURE__*/React.createElement(chakra.div, _extends({
  className: "chakra-stack__item"
}, props, {
  __css: _extends({
    display: "inline-block",
    flex: "0 0 auto",
    minWidth: 0
  }, props["__css"])
}));

/**
 * Stacks help you easily create flexible and automatically distributed layouts
 *
 * You can stack elements in the horizontal or vertical direction,
 * and apply a space or/and divider between each element.
 *
 * It uses `display: flex` internally and renders a `div`.
 *
 * @see Docs https://chakra-ui.com/components/stack
 *
 */
export var Stack = /*#__PURE__*/forwardRef(function Stack(props, ref) {
  var {
    isInline,
    direction,
    align,
    justify,
    spacing = "0.5rem",
    wrap,
    children,
    divider,
    className,
    shouldWrapChildren
  } = props,
      rest = _objectWithoutPropertiesLoose(props, ["isInline", "direction", "align", "justify", "spacing", "wrap", "children", "divider", "className", "shouldWrapChildren"]);

  var _direction = isInline ? "row" : direction != null ? direction : "column";
  /**
   * If we ever run into SSR issues with this, check this post to find a fix for it:
   * @see https://medium.com/@emmenko/patching-lobotomized-owl-selector-for-emotion-ssr-5a582a3c424c
   */


  var selector = "& > *:not(style) ~ *:not(style)";
  var directionStyles = {
    column: {
      mt: spacing,
      ml: 0
    },
    row: {
      ml: spacing,
      mt: 0
    },
    "column-reverse": {
      mb: spacing,
      mr: 0
    },
    "row-reverse": {
      mr: spacing,
      mb: 0
    }
  };
  var styles = {
    flexDirection: _direction,
    [selector]: mapResponsive(_direction, value => directionStyles[value])
  };
  var dividerStyles = mapResponsive(_direction, value => {
    if (value.includes("row")) {
      return {
        mx: spacing,
        my: 0,
        borderLeftWidth: "1px",
        borderBottomWidth: 0
      };
    }

    return {
      mx: 0,
      my: spacing,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    };
  });
  var hasDivider = !!divider;
  var shouldUseChildren = !shouldWrapChildren && !hasDivider;
  var validChildren = getValidChildren(children);
  var clones = shouldUseChildren ? validChildren : validChildren.map((child, index) => {
    var isLast = index + 1 === validChildren.length;

    var _child = shouldWrapChildren ? /*#__PURE__*/React.createElement(StackItem, {
      key: index
    }, child) : child;

    if (!hasDivider) return _child;
    var cloneDivider = isLast ? null : /*#__PURE__*/React.cloneElement(divider, {
      sx: _extends({
        "&": dividerStyles
      }, divider == null ? void 0 : divider.props.sx)
    });
    return /*#__PURE__*/React.createElement(React.Fragment, {
      key: index
    }, _child, cloneDivider);
  });

  var _className = cx("chakra-stack", className);

  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    display: "flex",
    alignItems: align,
    justifyContent: justify,
    flexDirection: styles.flexDirection,
    flexWrap: wrap,
    className: _className,
    __css: hasDivider ? {} : {
      [selector]: styles[selector]
    }
  }, rest), clones);
});

if (__DEV__) {
  Stack.displayName = "Stack";
}
/**
 * A view that arranges its children in a horizontal line.
 */


export var HStack = /*#__PURE__*/forwardRef((props, ref) => {
  return /*#__PURE__*/React.createElement(Stack, _extends({
    align: "center"
  }, props, {
    direction: "row",
    ref: ref
  }));
});

if (__DEV__) {
  HStack.displayName = "HStack";
}
/**
 * A view that arranges its children in a vertical line.
 */


export var VStack = /*#__PURE__*/forwardRef((props, ref) => {
  return /*#__PURE__*/React.createElement(Stack, _extends({
    align: "center"
  }, props, {
    direction: "column",
    ref: ref
  }));
});

if (__DEV__) {
  VStack.displayName = "VStack";
}
//# sourceMappingURL=stack.js.map