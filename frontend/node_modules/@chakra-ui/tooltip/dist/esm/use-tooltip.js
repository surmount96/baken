function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useDisclosure, useEventListener, useId } from "@chakra-ui/hooks";
import { usePopper } from "@chakra-ui/popper";
import { callAllHandlers, mergeRefs, mergeWith } from "@chakra-ui/utils";
import { useCallback, useEffect, useRef } from "react";
export function useTooltip(props) {
  if (props === void 0) {
    props = {};
  }

  var {
    openDelay = 0,
    closeDelay = 0,
    closeOnClick = true,
    closeOnMouseDown,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    placement,
    id,
    isOpen: isOpenProp,
    defaultIsOpen,
    arrowSize = 10,
    arrowShadowColor,
    arrowPadding,
    modifiers,
    isDisabled,
    gutter,
    offset
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["openDelay", "closeDelay", "closeOnClick", "closeOnMouseDown", "onOpen", "onClose", "placement", "id", "isOpen", "defaultIsOpen", "arrowSize", "arrowShadowColor", "arrowPadding", "modifiers", "isDisabled", "gutter", "offset"]);

  var {
    isOpen,
    onOpen,
    onClose
  } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  var popper = usePopper({
    placement,
    arrowSize,
    arrowShadowColor,
    arrowPadding,
    modifiers,
    gutter,
    offset
  });
  var tooltipId = useId(id, "tooltip");
  var ref = useRef(null);
  var enterTimeout = useRef();
  var exitTimeout = useRef();
  var openWithDelay = useCallback(() => {
    if (!isDisabled) {
      enterTimeout.current = window.setTimeout(onOpen, openDelay);
    }
  }, [isDisabled, onOpen, openDelay]);
  var closeWithDelay = useCallback(() => {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
    }

    exitTimeout.current = window.setTimeout(onClose, closeDelay);
  }, [closeDelay, onClose]);
  var onClick = useCallback(() => {
    if (closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay]);
  var onMouseDown = useCallback(() => {
    if (closeOnMouseDown) {
      closeWithDelay();
    }
  }, [closeOnMouseDown, closeWithDelay]);

  var onKeyDown = event => {
    if (isOpen && event.key === "Escape") {
      closeWithDelay();
    }
  };

  useEventListener("keydown", onKeyDown);
  useEffect(() => {
    return () => {
      clearTimeout(enterTimeout.current);
      clearTimeout(exitTimeout.current);
    };
  }, []);
  /**
   * This allows for catching mouseleave events when the tooltip
   * trigger is disabled. There's currently a known issue in
   * React regarding the onMouseLeave polyfill.
   * @see https://github.com/facebook/react/issues/11972
   */

  useEventListener("mouseleave", closeWithDelay, ref.current);

  var getTriggerProps = function getTriggerProps(props, _ref) {
    if (props === void 0) {
      props = {};
    }

    if (_ref === void 0) {
      _ref = null;
    }

    var triggerProps = _extends({}, props, {
      onMouseEnter: callAllHandlers(props.onMouseEnter, openWithDelay),
      onClick: callAllHandlers(props.onClick, onClick),
      onMouseDown: callAllHandlers(props.onMouseDown, onMouseDown),
      onFocus: callAllHandlers(props.onFocus, openWithDelay),
      onBlur: callAllHandlers(props.onBlur, closeWithDelay),
      "aria-describedby": isOpen ? tooltipId : undefined
    });

    return popper.getReferenceProps(triggerProps, mergeRefs(ref, _ref));
  };

  var getTooltipProps = function getTooltipProps(props, _ref) {
    if (props === void 0) {
      props = {};
    }

    if (_ref === void 0) {
      _ref = null;
    }

    var tooltipProps = _extends({
      ref: _ref
    }, htmlProps, props, {
      id: tooltipId,
      role: "tooltip"
    });

    return tooltipProps;
  };

  var getTooltipWrapperProps = function getTooltipWrapperProps(props, _ref) {
    if (props === void 0) {
      props = {};
    }

    if (_ref === void 0) {
      _ref = null;
    }

    return popper.getPopperProps(mergeWith(props, {
      style: {
        transformOrigin: popper.transformOrigin
      }
    }), _ref);
  };

  return {
    isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    getTriggerProps,
    getTooltipProps,
    getTooltipWrapperProps,
    transformOrigin: popper.transformOrigin,
    placement: popper.placement,
    getArrowWrapperProps: popper.getArrowWrapperProps,
    getArrowProps: popper.getArrowProps
  };
}
//# sourceMappingURL=use-tooltip.js.map